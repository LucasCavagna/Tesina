\chapter{Implementaciones adicionales para  \textit{piecewise map} ordenados}


Al igual que en el caso de los conjuntos ordenados, aquí también se definieron ciertas operaciones adicionales que resultan útiles para la implementación de los \textit{piecewise maps} ordenados, pero que no pueden formar parte de la biblioteca en sí misma.

\textbf{Pseudocódigo y notación}: A partir de este capitulo en adelante se utilizara la siguiente notación para simplificar lo mas posible el pseudocódigo:

\begin{itemize}
    \item Ahora $A_i$ representa la $i$-esima entrada de mapa o \texttt{MapEntry} de $A$ siendo $A$ un \textit{piecewise map} ordenado y con $0 \leq i < |A|$. Es el equivalente a \texttt{A.pieces\_[$i$]} en C++.

    \item Dado $a$ una entrada de mapa(\texttt{MapEntry}) de un \textit{piecewise map} ordenado $A$:
    \begin{itemize}
        \item $\mathrm{maxPer}(a)$: en C++ es equivalente a \texttt{a.second.second}, 
        lo que permite acceder al máximo perimetral asociado al conjunto dominio 
        del mapa contenido en la entrada de mapa, el cual, a su vez, se encuentra 
        dentro del perímetro(\texttt{SetPerimeter}) también incluido en dicha entrada de mapa.
        
        \item $\mathrm{minPer}(a)$: en C++ es equivalente a \texttt{a.second.first}, 
        lo que permite acceder al mínimo perimetral asociado al conjunto dominio 
        del mapa contenido en la entrada de mapa, el cual, a su vez, se encuentra 
        dentro del perímetro(\texttt{SetPerimeter}) también incluido en dicha entrada de mapa.

        \item $\mathrm{map}(a)$: es equivalente a, en C++, \texttt{a.first} que permite acceder al mapa que esta contenido en la entrada de mapa.

        \item $\mathrm{setPer}(a)$: es equivalente a, en C++, \texttt{a.second} que permite acceder al perímetro  del mapa que esta contenido en la entrada de mapa que contiene el máximo y mínimo perimetral de dominio del mapa.
    \end{itemize}

    \item Dado $p$ un perímetro(\texttt{SetPerimeter}) de un entrada de mapa:
    \begin{itemize}
        \item $\mathrm{maxPer}(p)$: es equivalente a, en C++, \texttt{p.second} que permite acceder al máximo perimetral que tiene asociado el perímetro $p$ que esta contenido en la entrada de mapa.
        \item $\mathrm{minPer}(p)$: es equivalente a, en C++, \texttt{a.first} que permite acceder al mínimo perimetral que tiene asociado el perímetro $p$ que esta contenido en la entrada de mapa.
    \end{itemize}

\end{itemize}




\section*{Calculo de perímetro - \texttt{calculatePerimeter}}

Esta operación adicional permite calcular el perímetro de un conjunto, es decir, determinar su mínimo y máximo perimetral.

La función \texttt{calculatePerimeter} resulta prácticamente fundamental, ya que proporciona estos dos valores clave que son utilizados tanto para establecer el orden de los mapas dentro de un \textit{piecewise map} ordenado asi como tambien para habilitar todas las optimizaciones descritas en la sección correspondiente para los \textit{piecewise maps} ordenados.


\begin{algorithm}
\caption{Cálculo del perímetro de un conjunto}
\label{alg:calculatePerimeter}
\begin{algorithmic}[1]
\Require $S$ es un conjunto de multi-intervalos.
\Ensure Devuelve un perímetro.
\Function{calculatePerimeter}{$S$}
    \State $d \gets$ \Call{arity}{$S$}
    \State $max\_per \gets (0)^d$ \Comment{\texttt{MD\_NAT} de ceros de longitud $d$}
    \State $min\_per \gets (\texttt{Inf})^d$ \Comment{\texttt{MD\_NAT} de valores Inf de longitud $d$}
    \ForAll{$s \in S$}
        \State $candidate\_max \gets$ \Call{maxElem}{$s$}
        \State $candidate\_min \gets$ \Call{minElem}{$s$}
        \For{$i = 0$ \textbf{to} $d-1$}
            \State $max\_per[i] \gets \max(max\_per[i],\,candidate\_max[i])$
            \State $min\_per[i] \gets \min(min\_per[i],\,candidate\_min[i])$
        \EndFor
    \EndFor
    \State \Return $\llcorner\mathit{min\_per},\,\mathit{max\_per}\urcorner$ \Comment{Perímetro resultante}
\EndFunction
\end{algorithmic}
\end{algorithm}

\section*{Calculo de solapamiento - \texttt{doInt}}

Esta operación funciona como análoga a su homónima definida para conjuntos ordenados, que manejaba solapamiento entre multi-intervalos. Su propósito es verificar si existe solapamiento entre dos conjuntos, utilizando únicamente sus valores mínimos y máximos perimetrales de los conjuntos.

Para ello, se ocupan los perímetros de los conjuntos y se evalúa si existe solapamiento entre los conjuntos en base a estos.

El pseudocódigo correspondiente puede verse a continuación en la figura~\ref{alg:doIntPerimeter}.


\begin{algorithm}
\caption{Calculo de solapamiento de conjuntos}
\label{alg:doIntPerimeter}
\begin{algorithmic}[1]
\Require $P\_1$ y $P\_2$ son dos perímetros.
\Ensure Devuelve \texttt{true} si los conjuntos de los perímetros se solapan, \texttt{false} en caso contrario.
\Function{doInt}{$P\_1, P\_2$}
    \State $max\_1 \gets \mathrm{maxPer}(P\_1)$
    \State $min\_1 \gets \mathrm{minPer}(P\_1)$
    \State $max\_2 \gets \mathrm{maxPer}(P\_2)$
    \State $min\_2 \gets \mathrm{minPer}(P\_2)$
    \State $d \gets$ \Call{arity}{$max\_1$}
    \For{$j = 0$ \textbf{to} $d-1$}
        \If{$max\_1[j] < min\_2[j]$ \textbf{or} $max\_2[j] < min\_1[j]$}
            \State \Return \texttt{false} \Comment{No hay solapamiento}
        \EndIf
    \EndFor
    \State \Return \texttt{true}  \Comment{Solapamiento detectado}
\EndFunction
\end{algorithmic}
\end{algorithm}


\section*{Creación de entradas de mapas - \texttt{createMapEntry}}

Esta operación se encarga simplemente de gestionar la creación de una entrada de mapa, \textit{MapEntry}, a partir de un mapa dado como argumento. Durante este proceso, se calcula su perímetro con el fin de completar la información faltante y construir correctamente la entrada de mapa.

El pseudocódigo correspondiente puede verse en la figura~\ref{alg:createMapEntry}.


\begin{algorithm}
\caption{Función de creación de entradas para mapas}
\label{alg:createMapEntry}
\begin{algorithmic}[1]
\Require $M$ es un mapa.
\Ensure Devuelve una entrada de mapa.
\Function{createMapEntry}{$M$}
    \State $sp \gets  \mathrm{calculatePerimeter}(\Call{dom}{M})$
    \State \Return $\lfloor\,M,\;sp\rceil$ \Comment{Entrada de mapa resultante}
\EndFunction
\end{algorithmic}
\end{algorithm}

\section*{Comparación de entradas de mapas - \texttt{mapEntryComp}}

Esta operación actúa únicamente como un predicado, tomando dos entradas de mapa (\texttt{MapEntry}) y comparando cuál de ellas tiene un mapa menor, basándose exclusivamente en los mínimos perimetrales que ambas entradas contienen dentro sus correspondientes perímetros.

En particular, esta función tiene un único uso dentro de toda la implementación de \textit{piecewise map} ordenados: ordenar un \textit{piecewise map} en base a un algoritmo de ordenamiento, el cual utiliza esta función.

El código correspondiente a esta operación es sumamente simple y puede verse en el pseudocódigo ~\ref{mapEntryComp}.


\begin{algorithm}
\caption{Comparación de mínimos perimetrales de dos entradas de mapas}
\label{alg:mapEntryComp}
\begin{algorithmic}[1]
\Require $E\_1$ y $E\_2$ son dos entradas de mapas
\Ensure Devuelve \texttt{true} si el mínimo perimetral de $E\_1$ es menor que el de $E\_2$
\Function{mapEntryComp}{$E\_1, E\_2$}
    \State $min\_1 \gets \mathrm{minPer}(E\_1)$
    \State $min\_2 \gets \mathrm{minPer}(E\_2)$
    \State \Return $min\_1 < min\_2$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section*{Agregar entrada al final - \texttt{pushBack}}

Esta operación permite insertar una entrada de mapa al final de un \textit{piecewise map} ordenado, asumiendo que su dominio no esté vacío. Su propósito principal es facilitar la incorporación de nuevas entradas sin necesidad de realizar un ordenamiento lineal completo, en los casos en que no se desea o no sea necesario verificar nuevamente si el dominio del mapa a insertar está vacío.

El pseudocódigo correspondiente se muestra en la figura~\ref{alg:pushBack}.

\begin{algorithm}
\caption{Agregar entrada al final para \textit{piecewise maps} ordenados}
\label{alg:pushBack}
\begin{algorithmic}[1]
\Require $A$ es un \textit{piecewise map} ordenado y $E$ es una entrada para mapa cuyo mapa tiene un dominio no vació.
\Ensure Agrega $E$ al final de $A$
\Function{pushBack}{$A,E$}
    \State $A \gets A \frown \ll E \gg$
\EndFunction
\end{algorithmic}
\end{algorithm}


\section*{Agregar mapa al final - \texttt{pushBack}}

Esta operación permite insertar un mapa al final de un \textit{piecewise map} ordenado, asumiendo que su dominio no esté vacío. Es básicamente análoga a la operación adicional anterior.

El pseudocódigo correspondiente se muestra en la figura~\ref{alg:pushBack2}.

\begin{algorithm}
\caption{Agregar amapa al final para \textit{piecewise maps} ordenados}
\label{alg:pushBack2}
\begin{algorithmic}[1]
\Require $A$ es un \textit{piecewise map} ordenado y $M$ es un mapa con dominio no vació.
\Ensure Agrega $E$ al final de $A$
\Function{pushBack}{$A,M$}
    \State $A \gets A \frown \ll \Call{createMapEntry}{M} \gg$
\EndFunction
\end{algorithmic}
\end{algorithm}

\section*{Inserción con pista - \texttt{emplaceHint}}

Esta operación inserta un nuevo mapa en un \textit{piecewise map} ordenado utilizando una posición sugerida (\textit{hint}), que es un numero positivo. A partir de dicha pista, se avanza hasta encontrar la ubicación adecuada según el valor mínimo perimetral del mapa a insertar en comparación con los mínimos perimetrales las entradas existentes en el \textit{piecewise map}. Esto permite mantener el orden sin necesidad de recorrer toda la estructura.

El pseudocódigo correspondiente se muestra en la figura~\ref{alg:emplaceHint-ord-map}.

\begin{algorithm}
\caption{Inserción ordenada de mapas con pista para \textit{piecewise maps} ordenados}
\label{alg:emplaceHint-ord-map}
\begin{algorithmic}[1]
\Require $A$ es un \textit{piecewise map} ordenado, $M$ es un mapa y $Hint$ es un numero positivo y una posición sugerida
\Ensure Inserta la entrada correspondiente a $M$ en posición ordenada a partir del $Hint$ en $A$
\Function{emplaceHint}{$A,\;M,\;hint$}
  \State $end \gets |A|$ 
  \State $it \gets Hint$ 
  \State $mpe \gets \mathrm{createMapEntry}(M)$
  \While{$it \ne end$}
    \If{$\mathrm{minPer}(A_{it}) < \mathrm{minPer}(mpe)$}
      \State $it$ \!+\!+
    \Else
      \State \textbf{break}
    \EndIf
  \EndWhile
  \State $A\gets A_{0:it-1} \frown \ll mdi\gg \frown A_{it:end-1}$
\EndFunction
\end{algorithmic}
\end{algorithm}


\section*{Avance de pista - \texttt{advanceHint}}

Esta función ajusta el valor de una pista (\textit{hint}),es un numero positivo, avanzando posiciones después de esta mientras los mapas de un \textit{piecewise map} ordenado presenten un mínimo perimetral menor que un valor de referencia dado. La lógica es similar a la utilizada en la operación anterior, aunque con algunas diferencias clave que pueden observarse en el pseudocódigo de la figura~\ref{alg:advanceHint-ord-map}.

\begin{algorithm}
\caption{Avance de pista para \textit{piecewise maps} ordenados}
\label{alg:advanceHint-ord-map}
\begin{algorithmic}[1]
\Require $A$ es un \textit{piecewise map} ordenado, $Crit$ es un mínimo perimetral y $Hint$ es un numero positivo y una posición sugerida
\Ensure Avanza el $Hint$ mientras los mínimos perimetrales sean menores que el $Crit$
\Function{advanceHint}{$A,\;Crit,\;Hint$}
  \State $end \gets |A|$ 
  \State $mpe \gets \mathrm{createMapEntry}(M)$
  \While{$Hint \ne end$}
    \If{$\mathrm{minPer}(A_{Hint}) < Crit$}
      \State $Hint$ \!+\!+
    \Else
      \State \textbf{break}
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\chapter{Implementaciones para \textit{piecewise maps} ordenados}

Llegado este punto, es momento de abordar las implementaciones concretas de las distintas operaciones sobre \textit{piecewise maps} ordenados. 

Este capítulo se organiza en cuatro secciones principales: una dedicada a aquellas operaciones cuya implementación no requirió modificaciones, una que aborda las operaciones adaptadas para poder funcionar correctamente en el contexto de \textit{piecewise maps} ordenados, y finalmente otra correspondiente a las operaciones que fueron optimizadas

Cabe destacar que, debido al cambio estructural de la variable \texttt{pieces} en los \textit{piecewise maps} ordenados con respecto a su contraparte desordenada, todas las operaciones debieron ser adaptadas para poder funcionar correctamente con esta nueva estructura interna.

Sin embargo, esta adaptación estructural no será considerada como una modificación en sí misma dentro del análisis, ya que responde únicamente a un requisito de compatibilidad con la representación de datos y no a un cambio en la lógica o el comportamiento de las operaciones.


\section{Operaciones sin cambios}

Al implementar los \textit{piecewise maps} ordenados sobre la base de la versión desordenada, se observó que ciertas operaciones no podían beneficiarse del orden para su optimización, pero tampoco alteraban dicho orden en la salida. Esto se debe, principalmente, a dos razones: o bien son operaciones que no devuelven un \textit{piecewise map}, o bien el \textit{piecewise map} resultante ya se encuentra ordenado.

Dentro del primer conjunto de operaciones se incluyen, por ejemplo: \texttt{dom}, que devuelve el dominio total de un \textit{piecewise map}; \texttt{arity}, que informa la aridad del mismo; \texttt{image}, que retorna su imagen; entre otras.

Dado que estas operaciones son numerosas y su comportamiento no resulta central para los objetivos de esta tesina, además de que sus implementaciones se mantuvieron sin modificaciones, no se detallarán aquí. Todas ellas pueden consultarse en el archivo \textit{pw\_map.cpp}, disponible en el repositorio de GitHub \cite{sbg}.

En el segundo conjunto se incluyen operaciones como \texttt{compact}, cuyo algoritmo no elimina el orden del \textit{piecewise map} resultante, o \texttt{mapInf}, cuya lógica interna se basa exclusivamente en operaciones que preservan dicho orden.

Al igual que en el caso anterior, dado que este conjunto tampoco es reducido y que las implementaciones no presentan particularidades relevantes para los objetivos de este escrito, se omite un desarrollo mas detallado aquí. Si se desea consultarlas en profundidad puede dirigirse al archivo correspondiente disponible en el repositorio de GitHub \cite{sbg}.

\section{Operaciones adaptadas al orden}

Este conjunto de operaciones puede dividirse, a su vez, en dos subgrupos: por un lado, aquellas que debieron ser forzosamente sometidas a un algoritmo de ordenamiento, y por otro, aquellas que fueron adaptadas específicamente para funcionar sobre \textit{piecewise maps} ordenados.

Dentro del primer grupo se encuentra, por ejemplo, la operación \texttt{inverse}, la cual trabaja sobre el inverso de los mapas. Esta particularidad dificulta considerablemente la preservación del orden durante la construcción del resultado, ya que ordenar mapas invertidos resulta complejo si no se realiza de forma estrictamente lineal, tal como se discutió en el capítulo dedicado a las optimizaciones para los \textit{piecewise maps} ordenados debido al trabajar con la imagen. Por este motivo, la operación \texttt{inverse} mantiene los mapas sin ordenar durante su ejecución y, únicamente antes de devolver el resultado, aplica un algoritmo de ordenamiento empleando la operación \texttt{mapEntryComp} como criterio de comparación.


Otra operación en este grupo es la operación \texttt{reduce}, en su versión sin argumentos. Como se analizó en el capítulo de conceptos previos, esta operación tiene un comportamiento particular. Internamente, invoca a una versión intermedia que recibe un mapa como argumento, la cual a su vez llama a una tercera implementación más profunda que recibe un intervalo y una expresión lineal. La cuestión radica en que esta última (la más profunda) sí devuelve un \textit{piecewise map} ordenado, pero la versión intermedia no, lo que provoca que al llegar a la versión sin argumentos, los resultados intermedios no estén ordenados.

En lugar de diseñar un criterio de ordenamiento específico para la versión de \texttt{reduce} que recibe mapas, lo cual resultaría complejo y poco práctico, o de realizar un ordenamiento estrictamente lineal,estrategia sumamente costosa, y de ademas incorporar la operación \texttt{concatenation} dentro de \texttt{reduce} sin argumentos para ir ordenando progresivamente el resultado, procedimiento también costoso, como se demostró en la optimización de dicha operación para \textit{piecewise maps} desordenados, se optó por una alternativa más simple y eficiente: aplicar directamente un algoritmo de ordenamiento al final sobre el resultado, utilizando nuevamente \texttt{mapEntryComp} como criterio de comparación.


En cuanto al algoritmo de ordenamiento utilizado se uso la operación \texttt{sort} disponible en la librería estándar.

Dentro del segundo grupo se encuentra la operación \texttt{emplaceBack}, que en esta nueva versión requiere realizar verificaciones adicionales. En particular, si el nuevo mapa no debe insertarse estrictamente al final del \textit{piecewise map}, la operación recurre a un procedimiento de búsqueda lineal para encontrar su posición óptima mediante el uso de \texttt{emplaceHint}.

Para profundizar en estos dos grupos de operaciones, puede consultarse el archivo \textit{pw\_map.cpp}, disponible en el repositorio de GitHub \cite{sbg}. Allí se presentan las adaptaciones de las distintas operaciones en función de sus homólogas para \textit{piecewise maps} desordenados.



\section{Operaciones optimadas}

En esta sección se presentarán todas aquellas operaciones que sí pudieron ser optimizadas mediante el aprovechamiento del orden en los \textit{piecewise maps}.

\subsection{Operaciones estructuralmente similares}

Como se analizó en la sección correspondiente, varias de estas operaciones comparten una estructura común, dividida en dos fases principales: una fase de comparación y un núcleo de operación. Para ejemplificar esta organización estructural se presentó, en su momento, un pseudocódigo bastante abstracto que capturaba dicho patrón estructural.

Basándose en ese esquema general, se desarrolló una operación concreta que implementa esta estructura de forma reutilizable. Dicha implementación puede observarse en los pseudocódigos ~\ref{alg:processOrdMaps1} y ~\ref{alg:processOrdMaps2}, donde se incorporan todos los criterios de optimización previamente definidos y validos para las diferentes operaciones vistas y analizadas, de manera análoga a como se hizo en la operación de intersección entre conjuntos ordenados. De esta manera cada operación puede utilizar esta operación de esqueleto, haciendo los cambios correspondientes a través de sus argumentos.

Cabe destacar además tres aspectos complementarios. En primer lugar, se incorporó un argumento adicional, $order\_mts$, a la operación general, el cual permite evitar la inversión del orden de los \textit{piecewise maps} argumentos debido al criterio de selección. Esta funcionalidad es necesaria para aquellas operaciones, como \texttt{-} y \texttt{minAdjMap}, que no admiten el criterio de selección y requieren mantener el orden original de los \textit{piecewise maps}.

En segundo lugar, se introdujo la variable \texttt{r\_pos}, como en la intersección de  conjuntos ordenados, la cual es utilizada específicamente en la suma \textit{piecewise maps} ordenados.

Por último, los argumentos $Set\_in$, $Set\_out$ y $Ord\_map$ están presentes debido a que las distintas operaciones utilizan, tanto internamente como en sus resultados, diferentes tipos de datos. Por ejemplo, la operación de suma (\texttt{+}) utiliza únicamente un \textit{piecewise map} ordenado como resultado, mientras que \texttt{equalImage} devuelve un conjunto. La función de cada uno de estos argumentos es la siguiente:
\begin{itemize}
    \item $Set\_in$: conjunto utilizado internamente durante la operación, pero que no se devuelve como resultado.
    \item $Set\_out$: conjunto que se genera como resultado de la operación.
    \item $Ord\_map$: \textit{piecewise map} ordenado que se genera como resultado de la operación.
\end{itemize}

En consecuencia, cada operación hará uso de los argumentos en función de lo que requieran tanto en el núcleo de la operación como en cuanto la salida que necesiten.


\begin{algorithm}
\caption{Procesado de \textit{piecewise maps} ordenados — Parte 1: Preparación}
\label{alg:processOrdMaps1}
\begin{algorithmic}[1]
\Require $C$ y $D$ son \textit{piecewise maps} ordenados
\Function{processOrdMaps}{$C, D\;Set\_in,\;Set\_out,\;Ord\_map,\;Process,\;Order\_mts$}

    \State $B \gets C$
    \State $A \gets D$

     \If{$\neg \, Order\_mts$ \textbf{and} $|D| < |C|$}
         \State $B \gets D$
         \State $A \gets C$
    \EndIf
          
    \
    
    \State $indeces \gets []$ \Comment{Es una lista simplemente enlazada}
    \For{$i = 0$; $i < |B|$; $i \gets i + 1$}
        \State $indices \gets indices$  \!+\!+  $[i]$
    \EndFor
        
    \
    
    \State $r\_pos \gets 0$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Procesado de \textit{piecewise maps} ordenados — Parte 2: verificación}
\label{alg:processOrdMaps2}
\begin{algorithmic}[1]
\Function{processOrdMaps(continuación)}{}
    \ForAll{$a \in A$}
        \State  $map\_a \gets \mathrm{map}(a)$
        \State  $p\_a \gets \mathrm{setPer}(a)$
    \

        \State $i \gets 0$
                
    \
    
        \While{$i \neq \Call{length}{indices}$}
                
    \
    
            \State $b \gets B_{indices[i]}$
            \State  $map\_b \gets \mathrm{map}(b)$
            \State  $p\_b \gets \mathrm{setPer}(b)$
    \
    
            \If{$\mathrm{maxPer}(p\_b)[0] < \mathrm{minPer}(p\_a)[0]$}
                \State $indices \gets indices 	\triangleleft  i$
                 \State $i$ \!+\!+ 
                \State \textbf{continue}
            \EndIf

            \If{$\mathrm{maxPer}(p\_a)[0] < \mathrm{minPer}(p\_b)[0]$}
                \State \textbf{break}
            \EndIf

\
            
            \If{\Call{doInt}{$p\_b$,$p\_a$}}
                \State \Call{Process}{$C,\;map\_b,\;map\_a,\;Set\_in,\;Set\_out,\;Ord\_map,\;r\_pos$}
            \EndIf
        
    \
    
            \State $i$ \!+\!+ 
        \EndWhile
        
    \
    
        \If{$indices == []$}
            \State \textbf{break}
        \EndIf
    \EndFor
        
\EndFunction
\end{algorithmic}
\end{algorithm}


Ahora bien, tanto en el caso de la suma como en el de las demás operaciones que seguían la estructura mencionada anteriormente, se realizaron las siguientes modificaciones: por un lado, se adaptó cada operación para que utilice a \texttt{processMapsOrd} como esqueleto estructural, encargándose de preparar todos los argumentos necesarios para su ejecución. Por otro lado, se separó el núcleo de cada una de las operaciones en una nueva función, la cual puede ser pasada como argumento al parámetro $Process$ de \texttt{processMapsOrd}. Para esto último, se definió un tipo específico para representar este tipo de funciones núcleo, denominado \textbf{ProcessFunc}, el cual puede encontrarse en el archivo \textit{pw\_map.hpp} de \cite{sbg}.

A continuación, se presentará cada una de ellas en detalle.

\subsubsection{Suma - \texttt{+}}

En el caso de la operación de suma, como se menciono anteriormente, se adapto para el uso de la operación esqueleto \texttt{processMapsOrd} y se separo su núcleo de la operación en una función denominada \texttt{processAdd}. Ambas pueden verse en los pseudocódigos ~\ref{alg:suma-ord} y ~\ref{alg:suma-ord-nucleo}, respectivamente.

En particular, el \textbf{criterio de ordenamiento} definido para la suma se aplica íntegramente en la función que contiene el núcleo de la operación~\ref{alg:suma-ord-nucleo}, específicamente entre las líneas 9 y 10.  
Cabe destacar que este criterio no se ejecuta de la misma forma que en la operación de intersección entre conjuntos ordenados.  
Dado que todas las operaciones comparten el mismo esqueleto mediante la función \texttt{processMapsOrd}, incluir la operación \texttt{advanceHint} dentro de \texttt{processMapsOrd} añadiría un costo adicional innecesario a las demás operaciones, ya que su uso forma parte únicamente del criterio de ordenamiento de la suma.  
Por lo tanto, la operación \texttt{advanceHint} se utiliza directamente en la función que implementa el núcleo de la suma.

\begin{algorithm}
\caption{Suma de \textit{piecewise maps} ordenados — Parte 1: Preparación}
\label{alg:suma-ord}
\begin{algorithmic}[1]
\Require $A$ y $B$ son \textit{piecewise maps} ordenados
\Ensure Devuelve un nuevo \textit{piecewise map} ordenado resultado de todas las sumas no vacías entre los mapas de $A$ como los de $B$
\Function{$+$}{$A, B$}
    \State $f \gets \Call{fact}{A}$
    \State $set\_in \gets \{\}_{\langle f \rangle}$
    \State $set\_out \gets \{\}_{\langle f \rangle}$
    \State $Ord\_pwmap \gets \ll\gg_{\langle f \rangle}$
    \State \Call{processOrdMaps}{$A,\;B,\;set\_in,\;set\_out,\;Ord\_pwmap,\;\text{processAdd},\;\texttt{false}$}
    \State \Return $Ord\_pwmap$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Suma de \textit{piecewise maps} ordenados — Parte 2: Procesamiento del núcleo de la suma}
\label{alg:suma-ord-nucleo}
\begin{algorithmic}[1]
\Require $M\_1$ y $M\_2$ son dos mapas, $Set\_in$ y $Set\_out$ son conjuntos, $Ord\_pwmap$ es un \textit{piecewise map} ordenado, $O\_pos$ es un valor positivo y $C$ es un \textit{piecewise map} ordenado que llama la operación
\Function{processAdd}{$C,\;M\_1,\;M\_2,\;Set\_in,\;Set\_out,\;Ord\_pwmap,\;O\_pos$}
    \State $res\_add \gets M\_1 + M\_2$
    \State $dom\_add \gets \Call{dom}{res\_add}$
    \State $empty \gets \Call{isEmpty}{dom\_add}$

    \If{$\neg\,\Call{isEmpty}{empty}$}
        \State $dom\_m\_2 \gets \Call{dom}{M\_2}$
        \State $per \gets \Call{calculatePerimeter}{dom\_m\_2}$
        \State $hintCrit \gets \mathrm{minPer}(per)$
        \State $\Call{advanceHint}{Ord\_pwmap,\;hintCrit,\;O\_pos}$
        \State \Call{emplaceHint}{$Ord\_pwmap,\;res\_add,\;O\_pos$}
    \EndIf
    \State \Return
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Igualdad de imágenes - \texttt{equalImage}}

Para el caso de la igualdad de imágenes, o \texttt{equalImage}, esta fue modificada y, adicionalmente, se definió la función \texttt{processEqualImage}, que actúa como el núcleo de la operación. Ambas pueden verse en ~\ref{alg:equalImage-ord} y ~\ref{alg:equalImage-ord-nucleo}, respectivamente.

Dado que esta operación no requiere un criterio de ordenamiento, su núcleo fue trasladado prácticamente sin modificaciones a \texttt{processEqualImage}.

\begin{algorithm}
\caption{Igualdad de imagines de \textit{piecewise maps} ordenados — Parte 1: Preparación}
\label{alg:equalImage-ord}
\begin{algorithmic}[1]
\Require $A$ y $B$ son dos \textit{piecewise maps} ordenados
\Ensure Devuelve el conjunto \texttt{Set} donde $A$ y $B$ son iguales en sus imágenes
\Function{equalImage}{$A, B$}
    \State $f \gets \Call{fact}{A}$
    \State $set\_in \gets \{\}_{\langle f \rangle}$
    \State $Set\_out \gets \{\}_{\langle f \rangle}$
    \State $ord\_pwmap \gets \ll\gg_{\langle f \rangle}$
    \State \Call{processOrdMaps}{$A, B, set\_in, Set\_out, ord\_pwmap, \text{processEqualImage}, \texttt{false}$}
    \State \Return $Set\_out$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Igualdad de imagines de \textit{piecewise maps} ordenados — Parte 2: Procesamiento del núcleo de la igualdad de imagenes}
\label{alg:equalImage-ord-nucleo}
\begin{algorithmic}[1]
\Require $M\_1$ y $M\_2$ son dos mapas, $Set\_in$ y $Set\_out$ son conjuntos, $Ord\_pwmap$ es un \textit{piecewise map} ordenado, $O\_pos$ es un valor positivo y $C$ es un \textit{piecewise map} ordenado que llama la operación
\Function{processEqualImage}{$C,\;M\_1,\;M\_2,\;Set\_in,\;Set\_out,\;Ord\_pwmap,\;O\_pos$}
    \State $f \gets \Call{fact}{A}$
    \State $dom\_m\_1 \gets \Call{dom}{M\_1}$
    \State $dom\_m\_2 \gets \Call{dom}{M\_2}$
    \State $cap\_dom \gets \Call{intersection}{dom\_m\_1, dom\_m\_2}$
    \State $empty \gets \Call{isEmpty}{cap\_dom}$
    \If{$\neg\,\Call{isEmpty}{empty}$}
        \State $m\_1\_cap \gets \{cap\_dom \rightarrow \Call{exp}{M\_1}\}_f$
        \State $m\_2\_cap \gets \{cap\_dom \rightarrow \Call{exp}{M\_2}\}_f$
        \If{$m\_1\_cap == m\_2\_cap$}
            \State $Set\_out \gets \Call{disjointCup}{Set\_out, cap\_dom}$
        \EndIf
    \EndIf
    \State \Return
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Resta - \texttt{-}}

La resta para \textit{piecewise maps} ordenados se modificó para funcionar utilizando la operación \texttt{processOrdMaps}, tal como se había planteado, cuyo pseudocódigo se presenta en~\ref{alg:resta-ord}.  
El núcleo de la operación se implementó en la función \texttt{processMinus}, cuyo pseudocódigo se muestra en~\ref{alg:resta-nuecleo-ord1}, \ref{alg:resta-nuecleo-ord2} y \ref{alg:resta-nuecleo-ord3}, debido a su gran extensión.


En el pseudocódigo~\ref{alg:resta-nuecleo-ord3} puede observarse cómo se ordena el resultado parcial, según lo establecido en el \textbf{criterio de ordenamiento} para la resta, a través de la operación \texttt{emplaceBack}.  
Posteriormente, los resultados parciales se incorporan al \textit{piecewise map} ordenado resultante mediante la operación \texttt{concatenation}, tal como se describió en dicho criterio.


\begin{algorithm}
\caption{Resta de \textit{piecewise maps} ordenados — Parte 1: Preparación}
\label{alg:resta-ord}
\begin{algorithmic}[1]
\Require $A$ y $B$ son \textit{piecewise maps} ordenados
\Ensure Devuelve un nuevo \textit{piecewise maps} ordenados que contiene todas las restas no vacías de los mapas de $A$ menos los de $B$
\Function{$-$}{$A, B$}
    \State $f \gets \Call{fact}{A}$
    \State $Ord\_map \gets \ll\gg_{\langle f \rangle}$
    \State $emptyA \gets \Call{isEmpty}{A}$
    \State $emptyB \gets \Call{isEmpty}{B}$
    \If{$emptyA$ \textbf{or} $emptyB$}
        \State \Return $Ord\_map$
    \EndIf

    \State $all \gets [0: 1: \texttt{Inf}]$ \Comment{Intervalo completo}
    \State$d \gets \Call{arity}{A}$
    \State $set\_in \gets \{|all|^{d}\}_{\langle f \rangle}$
    \State $set\_out \gets \{\}_{\langle f \rangle}$
    \State \Call{processOrdMaps}{$A, B, set\_in, set\_out, ord\_map, \text{processMinus}, \texttt{true}$}
    \State \Return $Ord\_map$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Resta de \textit{piecewise maps} ordenados — Parte 2-1: Procesamiento del núcleo de la resta}
\label{alg:resta-nuecleo-ord1}
\begin{algorithmic}[1]
\Require $M\_1$ y $M\_2$ son dos mapas, $Set\_in$ y $Set\_out$ son conjuntos, $Ord\_pwmap$ es un \textit{piecewise map} ordenado, $O\_pos$ es un valor positivo y $C$ es un \textit{piecewise map} ordenado que llama la operación
\Function{processMinus}{$C,\;M\_1,\;M\_2,\;Set\_in,\;Set\_out,\;Ord\_pwmap,\;O\_pos$}
     \State $dom\_1 \gets\Call{dom}{M\_1}$
     \State $dom\_2 \gets\Call{dom}{M\_2}$
    \State $dom \gets \Call{intersection}{dom\_1,dom\_2}$
    \If{$\Call{isEmpty}{dom}$}
        \State \Return
    \EndIf

    \State $minus\_exp \gets \Call{exp}{M\_1} - \Call{exp}{M\_2}$
    \State $f \gets \Call{fact}{Ord\_pwmap}$
     \State$d \gets \Call{arity}{Set\_in}$
    \State $ith \gets \ll\{Set\_in \rightarrow [1*x+0]^d \}_{langle f \rangle}\gg_{\langle f \rangle}$

    \State Parte 2-2...

    \State $restriction \gets  \Call{restrict}{ith, dom}$
    \State $concatenated \gets \Call{concatenation}{Ord\_pwmap,restriction }$

    \State $Ord\_pwmap \gets concatenated$
    \State \Return
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Resta de \textit{piecewise maps} ordenados — Parte 2-2: Procesamiento del núcleo de la resta}
\label{alg:resta-nuecleo-ord2}
\begin{algorithmic}[1]
\Require $M\_1$ y $M\_2$ son dos mapas, $Set\_in$ y $Set\_out$ son conjuntos, $Ord\_pwmap$ es un \textit{piecewise map} ordenado, $O\_pos$ es un valor positivo
\Function{processMinus}{}
    \For{$j \gets 0$ \textbf{to} $\Call{arity}{m_1} - 1$}
        \State $m \gets \Call{slope}{minus\_exp_j}$
        \State $h \gets \Call{offset}{minus\_exp_j}$

        \State $begin\_neg \gets 0$
        \State $end\_neg \gets \texttt{Inf}$
        \State $begin\_pos \gets 0$
        \State $end\_pos \gets \texttt{Inf}$

        \If{$m = 0$}
            \If{$h < 0$}
                \State $begin\_pos \gets 1$
                \State $end\_pos \gets 0$
            \Else
                \State $begin\_neg \gets 1$
                \State $end\_neg \gets 0$
            \EndIf
        \ElsIf{$m > 0$}
            \State $cross \gets -h / m$
            \If{$cross \ge 0$}
                \State $begin\_pos \gets \Call{toNat}{cross}$
                \If{$begin\_pos > 0$}
                    \State $end\_neg \gets begin\_pos - 1$
                \Else
                    \State $begin\_neg \gets 1$
                    \State $end\_neg \gets 0$
                \EndIf
            \EndIf
        \Else
            \State $cross \gets -h / m$
            \If{$cross \ge 0$}
                \State $end\_pos \gets \Call{toNat}{cross}$
                \If{$end\_pos > 0$}
                    \State $begin\_neg \gets end\_pos + 1$
                \EndIf
            \Else
                \State $begin\_pos \gets 1$
                \State $end\_pos \gets 0$
            \EndIf
        \EndIf

       \State Parte 2-3...
    \EndFor

\EndFunction
\end{algorithmic}
\end{algorithm}




\begin{algorithm}
\caption{Resta de \textit{piecewise maps} ordenados — Parte 2-3: Procesamiento del núcleo de la resta y guardado de resultados parciales}
\label{alg:resta-nuecleo-ord3}
\begin{algorithmic}[1]
\Require $M\_1$ y $M\_2$ son dos mapas, $Set\_in$ y $Set\_out$ son conjuntos, $Ord\_pwmap$ es un \textit{piecewise map} ordenado, $O\_pos$ es un valor positivo
\Function{processMinus}{}
 \State $jth \gets \ll\gg_{\langle f \rangle}$
        \State $neg \gets [begin\_neg: 1: end\_neg]$
        \State $pos \gets [begin\_pos: 1: end\_pos]$

        \ForAll{$mpe \in ith$}
            \State $m \gets \mathrm{map}(mpe)$
            \State $mdi \gets \Call{dom}{m}[0]$
            \State $e \gets \Call{exp}{m}$

            \If{$\neg \Call{isEmpty}{neg}$}
                \State $mdi_j \gets neg$
                \State $e_j \gets 0$
                \State $new\_map \gets \{mdi \rightarrow e\}_{\langle f \rangle}$
                \State \Call{emplaceBack}{$jth, new\_map$}
            \EndIf

            \If{$\neg \Call{isEmpty}{pos}$}
                \State $mdi_j \gets pos$
                \State $e_j \gets minus\_exp_j$
                \State $new\_map \gets \{mdi \rightarrow e\}_{\langle f \rangle}$
                \State \Call{emplaceBack}{$jth, new\_map$}
            \EndIf
        \EndFor

        \State $ith \gets jth$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsubsection{Mínimo adyacente - \texttt{minAdjMap}}

Al igual que en los casos anteriores, la operación se descompone en dos partes:  
la operación \textit{minAdjMap}, que emplea la operación esqueleto \texttt{processOrdMaps}, cuyo pseudocódigo se presenta en ~\ref{alg:minadj-ord};  
y la operación \texttt{processMinAdjMap}, que implementa el núcleo de la operación propiamente dicha, 
cuyo pseudocódigo puede observarse en \ref{alg:minadj-ord-proc}.

Adicionalmente, en ambos operaciones se emplea un algoritmo de ordenamiento 
basado en la operación \texttt{compMapEntry}.  
En el caso de la operación presentada en \ref{alg:minadj-ord}, dicho algoritmo 
se aplica en la línea~8 para ordenar el resultado final.  
En el segundo caso, el ordenamiento se realiza antes de utilizar el resultado 
en las operaciones de \textit{piecewise maps} ordenados, en la línea~29.

\begin{algorithm}
\caption{Mínimo adyacente — Parte 1: Preparación}
\label{alg:minadj-ord}
\begin{algorithmic}[1]
\Require $A$ y $B$ son \textit{piecewise maps} ordenados
\Ensure Devuelve un nuevo \textit{piecewise maps} ordenado 
\Function{minAdjMap}{$A, B$}
    \State $f \gets \Call{fact}{A}$
    \State $R \gets \ll\gg_{\langle f \rangle}$
    \State $set\_in \gets \{\}_{\langle f \rangle}$
    \State $set\_out \gets \{\}_{\langle f \rangle}$
    \State \Call{processOrdMaps}{$A, B, set\_in, set\_out, R, \text{processMinAdjMap}, \texttt{true}$}
    \State $\Call{sort}{R, \mathrm{mapEntryComp}}$
    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Mapa mínimo adyacente — Parte 2: Procesamiento del núcleo del mínimo adyacente}
\label{alg:minadj-ord-proc}
\begin{algorithmic}[1]
\Require $M\_1$ y $M\_2$ son dos mapas, $Set\_in$ y $Set\_out$ son conjuntos, $Ord\_pwmap$ es un \textit{piecewise map} ordenado, $O\_pos$ es un valor positivo y $C$ es un \textit{piecewise map} ordenado que llama la operación
\Function{processMinAdjMap}{$C,\;M\_1,\;M\_2,\;Set\_in,\;Set\_out,\;Ord\_pwmap,\;O\_pos$}
    \State $dom\_1 \gets \Call{dom}{M\_1}$
    \State $dom\_2 \gets \Call{dom}{M\_2}$
    \State $dom\_int \gets \Call{intersection}{dom\_1, dom\_2}$
    \If{$\Call{isEmpty}{dom\_int}$}
        \State \Return
    \EndIf

    \State $dom\_res \gets \Call{image}{M\_1, dom\_int}$
    \State $exp\_1 \gets \Call{exp}{M\_1}$
    \State $im\_2 \gets \Call{image}{M\_2, dom\_int}$

    \If{$\neg \Call{isConstant}{exp\_1}$}
        \State $exp\_2 \gets \Call{exp}{m_2}$
        \State $exp\_1\_i \gets \Call{inverse}{exp\_1}$
        \State $e\_res \gets \Call{composition}{exp\_2, exp\_1\_i}$
    \Else
        \State $min\_elem \gets \Call{minElem}{im\_2}$
        \State $d \gets \Call{arity}{im\_2}$
        \State $e\_res \gets [0*x+min\_elem[0],\dots,0*x+min\_elem[d]]$
    \EndIf

    \State $empty\_res \gets \Call{isEmpty}{dom\_res}$
    \If{$\neg \Call{isEmpty}{dom\_res}$}
        \State $fact \gets \Call{fact}{C}$
        \State $ith \gets \{dom\_res \rightarrow e\_res\}_{\langle fact \rangle}$
        \State $ith\_pw \gets \ll ith\gg_{\langle fact \rangle}$
        \State $again \gets \Call{intersection}{dom\_res, set\_in}$
        \State $empty\_again \gets \Call{isEmpty}{again}$

        \If{$\neg\Call{isEmpty}{again}$}
            \State $ord\_pwmap\_aux \gets Ord\_pwmap$
            \State $\Call{sort}{ord\_pwmap\_aux, \mathrm{mapEntryComp}}$
            \State $aux\_res \gets \Call{restrict}{ord\_pwmap\_aux, dom\_res}$
            \State $min\_map \gets \Call{minMap}{aux\_res, ith\_pw}$
            \State $comb \gets \Call{combine}{min\_map, ith\_pw}$
            \State $new\_res \gets \Call{combine}{comb, ord\_pwmap\_aux}$
            \State $new\_res \gets \Call{staticCast}{new\_resPtr}$
            \State $Ord\_pwmap \gets ord\_pwmap\_aux$
            \State $dom\_i \gets \Call{dom}{ith\_pw}$
            \State $set\_in \gets \Call{cup}{set\_in, dom\_i}$
        \Else
            \State $\mathrm{pushBack}(ord\_pwmap, ith)$
            \State $set\_in \gets \Call{disjointCup}{set\_in, dom\_res}$
        \EndIf
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}



\subsubsection{Igualdad - \texttt{==}}

El caso de la operación de igualdad para \textit{piecewise maps} ordenados resulta particularmente peculiar. Esta operación comparte una estructura muy similar con la intersección de conjuntos desordenados. Sin embargo, se diferencia en que el núcleo de la operación, ya que debe retornar el valor de verdad \texttt{false} en caso de que los operandos no sean iguales. Este requerimiento introduce una complicación adicional, ya que implicaría incluir chequeos en la operación esqueleto, \texttt{processMapsOrd} si se desea utilizar, lo cual no es deseable porque afectaría a todas las demás operaciones que reutilizan dicha estructura.

Por esta razón, y con el objetivo de preservar una reducción tangible en los tiempos de ejecución, se optó por realizar una copia casi directa de la operación \texttt{processMapsOrd} dentro de la operación de igualdad, sin separar su núcleo de la operación como se hizo en los casos anteriores. Y como se puede ver en el pseudocódigo \ref{alg:igualdad-ord1} y \ref{alg:igualdad-ord2} la operación quedo prácticamente igual a la intersección de conjuntos ordenados, salvo por el núcleo de la operación y el hecho de no tener criterio de ordenamiento.

\begin{algorithm}
\caption{Igualdad de \textit{piecewise maps} ordenados — Parte 1: Preparación}
\label{alg:igualdad-ord1}
\begin{algorithmic}[1]
\Require $C$ y $D$ son \textit{piecewise maps} ordenados
\Ensure Devuelve \texttt{true} sin los \textit{piecewise maps} son iguales. En caso contrario, devuelve \texttt{false}
\Function{==}{$C, D$}
    \State $f \gets \Call{fact}{A}$
    \State $R \gets \ll\gg_{\langle f \rangle}$

    \If{$\Call{dom}{C} == \Call{dom}{D}$}
        \State \Return{\texttt{false}}
    \EndIf

    \If{$C == D$}
        \State \Return{\texttt{true}}
    \EndIf
          
    \
    
    \State $B \gets C$
    \State $A \gets D$

    \If{$|D|$ $<$ $|C|$}
        \State $B \gets D$
        \State $A \gets C$
    \EndIf
        
    \
    
    \State $indeces \gets []$ \Comment{Es una lista simplemente enlazada}
    \For{$i = 0$; $i < |B|$; $i \gets i + 1$}
        \State $indices \gets indices$  \!+\!+  $[i]$
    \EndFor
        
    \

    \State Parte 2...
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Igualdad de \textit{piecewise maps} ordenados — Parte 2: verificación}
\label{alg:igualdad-ord2}
\begin{algorithmic}[1]
\Function{==(continuación)}{}
    \ForAll{$a \in A$}
        \State  $map\_a \gets \mathrm{map}(a)$
        \State  $p\_a \gets \mathrm{setPer}(a)$
    \

        \State $i \gets 0$
                
    \
    
        \While{$i \neq \Call{length}{indices}$}
                
    \
    
            \State $b \gets B_{indices[i]}$
            \State  $map\_b \gets \mathrm{map}(b)$
            \State  $p\_b \gets \mathrm{setPer}(b)$
    \
    
            \If{$\mathrm{maxPer}(p\_b)[0] < \mathrm{minPer}(p\_a)[0]$}
                \State $indices \gets indices 	\triangleleft  i$
                 \State $i$ \!+\!+ 
                \State \textbf{continue}
            \EndIf

            \If{$\mathrm{maxPer}(p\_a)[0] < \mathrm{minPer}(p\_)[0]$}
                \State \textbf{break}
            \EndIf

\
            
            \If{\Call{doInt}{$p\_b$,$p\_a$}}
                \State $dom\_a \gets \Call{dom}{map\_a}$
                \State $dom\_b \gets \Call{dom}{map\_b}$
                 \State $cap\_dom \gets \Call{dom}{dom\_a, dom\_b}$
                \If{$\neg\,\Call{isEmpty}{cap\_dom}$}
                    \If{$\Call{cardinal}{cap\_dom} == 1$}
                        \State $m\_1 \gets \{cap\_dom \rightarrow \Call{exp}{map\_a}\}_{\langle f \rangle}$
                        \State $m\_2 \gets \{cap\_dom \rightarrow \Call{exp}{map\_b}\}_{\langle f \rangle}$
                        \If{$\Call{image}{m\_1} \neq\Call{image}{m\_2}$}
                            \State \Return{\texttt{false}}
                        \EndIf
                    \Else
                        \If{$\Call{exp}{map\_a} \neq \Call{exp}{map\_b}$}
                            \State \Return{\texttt{false}}
                        \EndIf
                    \EndIf
                \EndIf
            \EndIf
            
        
    \
    
            \State $i$ \!+\!+ 
        \EndWhile
        
    \
    
        \If{$indices == []$}
            \State \textbf{break}
        \EndIf
    \EndFor
            
    \
    
    \State \Return{\texttt{true}}
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Restricción de dominio - \texttt{restrict}}

La operación \texttt{restrict}, como se analizó en su sección correspondiente dentro del capítulo donde se vieron los criterios de optimización y ordenamiento para \textit{piecewise maps} ordenados, cuenta con un \textbf{criterio de parada}, un \textbf{criterio de solapamiento} y un \textbf{criterio de ordenamiento}.

En el pseudocódigo~\ref{alg:restrict-ord} puede verse cómo quedó la operación tras aplicar todos los criterios mencionados:

\begin{itemize}
    \item El \textbf{criterio de parada} se encuentra implementado entre las líneas 22 y 23.
    
    \item El \textbf{criterio de solapamiento} aparece en la línea 14, gracias al uso de la operación adicional \texttt{doInt}.
    
    \item Finalmente, el \textbf{criterio de ordenamiento} se implementa mediante las operaciones auxiliares \texttt{emplaceHint} y \texttt{advanceHint}, ubicadas en las líneas 19 y 20 respectivamente, junto con el uso de la variable $r\_pos$ declarada en la línea 7.
\end{itemize}


\begin{algorithm}
\caption{Restriccion de dominio para \textit{piecewise maps} ordenados}
\label{alg:restrict-ord}
\begin{algorithmic}[1]
\Require $A$ es un \textit{piecewise map} ordenado y $S$ es un conjunto
\Ensure Devuelve un nuevo \textit{piecewise map} cuyos mapas están restringidos en su domino por $S$
\Function{restrict}{$A, S$}
    \State $f \gets$ \Call{fact}{$A$}
    \State $R \gets \ll\gg_{\langle f \rangle}$
    \If{\Call{isEmpty}{$S$}}
        \State \Return $R$
    \EndIf

    \State $r\_pos \gets 0$
    \State $s\_sp \gets$ \Call{calculatePerimeter}{$S$}
    \State $s\_max\_per \gets \mathrm{maxPer}(s\_sp)$

    \ForAll{$a \in A$}
        \State  $a\_map \gets \mathrm{map}(a)$
        \State  $a\_sp \gets \mathrm{setPer}(a)$
        \State $a\_min\_per \gets \mathrm{minPer}(p)$
    

        \If{\Call{doInt}{$a\_sp, s\_sp$}}
            \State $rest\_map \gets \Call{restrict}{a\_map,S}$
            \If{$\neg\;$\Call{isEmpty}{$rest\_map$}}
                \State \Call{advanceHint}{$R,\;a\_min\_per,\;r\_pos$}
                \State \Call{emplaceHint}{$R,\;rest\_map,\;r\_pos$}
            \EndIf
            \State \textbf{continue}
        \EndIf

        \If{$s\_max\_per[0] < a\_min\_per[0]$}
            \State \textbf{break}
        \EndIf

    \EndFor

    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Combinación - \texttt{combine}}

Como se analizó previamente, la operación \texttt{combine} cuenta únicamente con un criterio de optimización, además de su correspondiente criterio de ordenamiento. En el pseudocódigo~\ref{alg:combine-ord} puede observarse el código final de la operación, donde:

\begin{itemize}
    \item El \textbf{criterio de solapamiento} se aplica, como en otros casos, mediante la operación adicional \texttt{doInt}, ubicada en la línea 19.
    \item El \textbf{criterio de ordenamiento} se implementa mediante el uso de las funciones auxiliares \texttt{emplaceHint} y \texttt{advanceHint}, en las líneas 27 y 28 respectivamente, junto con la utilización de la variable $r\_pos$.
\end{itemize}


\begin{algorithm}
\caption{Combinación de \textit{piecewise maps} ordenados}
\label{alg:combine-ord}
\begin{algorithmic}[1]
\Require $A$ y $O$ son \textit{piecewise maps} ordenados
\Ensure Devuelve un nuevo \textit{piecewise map} ordenado que resulta de añadir a $A$ los mapas de $O$ restringidos en su dominio a valores no presentes en el dominio de $A$
\Function{combine}{$A, O$}
    \State $f \gets$ \Call{fact}{$A$}
    \State $R \gets$ $A$            
    \If{\Call{isEmpty}{$A$}}
        \State \Return $O$
    \EndIf
    \If{\Call{isEmpty}{$O$}}
        \State \Return $A$
    \EndIf

    \State $r\_pos \gets 0$
    \State $dom\_a \gets \Call{dom}{A}$
    \State $a\_sp \gets$ \Call{calculatePerimeter}{$dom\_a$}

    \ForAll{$o \in O$}
        \State $o\_map \gets \mathrm{map}(o)$
        \State $o\_sp \gets \mathrm{setPer}(o)$
        \State $dom\_o\_map \gets$ \Call{dom}{$o\_map$}
        \State $exp\_o\_map \gets$ \Call{exp}{$o\_map$}
        \State $res\_comb \gets\{dom\_o\_map \rightarrow exp\_o\_map\}_{\langle f \rangle}$

        \If{\Call{doInt}{$o\_sp, a\_sp$}}
            \State $new\_dom \gets \Call{difference}{dom\_o\_map,dom\_a}$
            \If{\Call{isEmpty}{$new\_dom$}}
                \State \textbf{continue}
            \EndIf
            \State $res\_comb \gets\{new\_dom \rightarrow exp\_o\_map\}_{\langle f \rangle}$ 
        \EndIf

        \State $hint\_crit \gets \mathrm{minPer}(o\_sp)$
        \State \Call{advanceHint}{$R,\;hint\_crit,\;r\_pos$}
        \State \Call{emplaceHint}{$R,\;res\_comb,\;r\_pos$}
    \EndFor

    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Concatenación - \texttt{concatenation}}

Esta operación, como ya se analizó, es básicamente análoga a la operación 
de unión disjunta de conjuntos ordenados.  
Por este motivo, su implementación resulta sumamente similar, 
como puede apreciarse en el pseudocódigo~\ref{alg:concatenation-ord}.


\begin{algorithm}
\caption{Concatenación de \textit{piecewise maps} ordenados}
\label{alg:concatenation-ord}
\begin{algorithmic}[1]
\Require $A$ y $B$ son \textit{piecewise maps} ordenados disjuntos
\Ensure Devuelve un nuevo \textit{piecewise map} ordenado con los mapas de $A$ y de $B$
\Function{concatenation}{$A, B$}
    \State $f \gets \mathrm{fact}(A)$
    \State $R \gets \ll\gg_{\langle f \rangle}$ 

    \If{\Call{isEmpty}{$A$}}
        \State \Return $B$
    \EndIf
    \If{\Call{isEmpty}{$B$}}
        \State \Return$A$
    \EndIf
    
 \

    \State $end\_a \gets |A|$
    \State $last\_a \gets \mathrm{minPer}(A_{end\_a-1})$
    \State $first\_b \gets \mathrm{minPer}(B_0)$
    \If{$last\_a < first\_b$}
        \State \Return $A \frown B$
    \EndIf

    \State $end\_b \gets |B|$
    \State $last\_b \gets \mathrm{minPer}(B_{end\_b-1})$
    \State $first\_a \gets \mathrm{minPer}(A_0)$
    \If{$last\_b < first\_a$}
       \State \Return $B \frown A$
    \EndIf

 \

    \State $i\_a  \gets 0$
    \State $i\_b  \gets 0$

    \For{;$i\_a \neq end\_a$ \textbf{and} $i\_b \neq end\_b$;}
    
 \

        \State $min\_a \gets \mathrm{minPer}(A_{i\_a})$
        \State $min\_b \gets \mathrm{minPer}(B_{i\_b})$

 \

      \If{$min\_a < min\_b$} 
        \State $ \mathrm{pushBack} (R, A_{i\_a})$
        \State $i\_a$ \!+\!+
      \Else 
        \State $\mathrm{pushBack} (R, B_{i\_b})$
        \State $i\_b$ \!+\!+
      \EndIf   
    \EndFor
    
    \
    
    \State $R \gets R \frown A_{i\_a:end\_a - 1}$
    \State $R \gets R \frown B_{i\_b:end\_b - 1}$
    
    \
    
    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}



\subsection{Composición - \texttt{composition}}

La operación de composición de \textit{peicewise maps} ordenados, luego de aplicarle todos los criterios de optimización y de ordenamiento que se plantearon para ella, quedo como se puede ver en el pseudocódigo \ref{alg:composition-ord}. En este se observa que los criterios quedaron dispuestos de la siguiente manera:

\begin{itemize}
    \item El \textbf{criterio de parada} se encuentra implementado entre las líneas 22 y 23.
    
    \item El \textbf{criterio de solapamiento} aparece en la línea 15, gracias al uso de la operación adicional \texttt{doInt}.
    
    \item Y, por ultimo, el \textbf{criterio de ordenamiento} se implementa mediante las operaciones auxiliares \texttt{emplaceHint} y \texttt{advanceHint}, ubicadas en las líneas 18 y 10 respectivamente, junto con el uso de la variable $r\_pos$ declarada en la línea 4.
\end{itemize}




\begin{algorithm}
\caption{\texttt{composition}: Composición de dos mapas piecewise ordenados}
\label{alg:composition-ord}
\begin{algorithmic}[1]
\Require $A$ y $B$ son dos \textit{piecewise maps} ordenados
\Ensure Devuelve un nuevo \textit{piecewise map} cuyos mapas son las composiciones no vacías de los mapas de $A$ con $B$
\Function{composition}{$A, B$}
    \State $f \gets \mathrm{fact}(A)$
    \State $R \gets \ll\gg_{\langle f \rangle}$   
    \State $r\_pos \gets 0$

    \ForAll{$b \in b$}
        \State $b\_map \gets \mathrm{map}(b)$
        \State $img \gets \mathrm{image}(b_map)$
        \State $i\_sp \gets$ \Call{calculatePerimeter}{$img$}
        \State $i\_max\_per \gets \mathrm{maxPer}(i\_sp)$

        \State \Call{advanceHint}{$R,\,\mathrm{minPer}(b),\,r\_ros$}

        \ForAll{$a \in A$}
            \State $a\_map \gets \mathrm{map}(a)$
            \State $a\_sp \gets \mathrm{setPer}(a)$
            \State $a\_min\_per \gets \mathrm{minPer}(a\_p)$



            \If{\Call{doInt}{$a\_sp,\,i\_sp$}}
                \State $comp\_map \gets \Call{composition}{a\_map,b\_map}$
                \If{$\neg\,$\Call{isEmpty}{$comp\_map$}}
                    \State \Call{emplaceHint}{$R,\,comp\_map,\,r\_pos$}
                \EndIf
                \State \textbf{continue}
            \EndIf

            \If{$i\_max\_per[0] < a\_min\_per[0]$}
                \State \textbf{break}
            \EndIf
        \EndFor
    \EndFor

    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}





\subsection{Pseudoinversa - \texttt{firstInv}}

Ahora es el turno de la operación \texttt{firstInv}, la cual presenta la particularidad 
de disponer de dos \textbf{criterios de solapamiento} debido a la forma en que actúa internamente.  
Estos, junto con el \textbf{criterio de parada}, pueden apreciarse con claridad en el pseudocódigo~\ref{alg:firstInv-ord}.  
En particular, los criterios se distribuyen de la siguiente manera:


\begin{itemize}
    \item El \textbf{criterio de parada} se encuentra implementado entre las líneas 40 y 42.
    
    \item El \textbf{criterio de solapamiento} aparece en la línea 14, gracias al uso de la operación adicional \texttt{doInt} aplicada a el perímetro de $a$ y el de $S$.

    \item Por otro lado, el\textbf{criterio de solapamiento para $visisted$} aparece en la línea 20, gracias al uso de la operación adicional \texttt{doInt} aplicada a el perímetro de $img$ y el de $visited$.
\end{itemize}

Nuevamente en este caso, se hace uso de un algoritmo de ordenamiento para poder ordenar correctamente la salida de la operación.

\begin{algorithm}
\caption{Primer invertido para \textit{piecewise maps} ordenandos}
\label{alg:firstInv-ord}
\begin{algorithmic}[1]
\Require $A$ es un \textit{piecewise map} ordenando y $S$ es un conjunto
\Ensure Devuelve las pseudoinversas de los mapas de $A$ restringidas en su dominio para que sean disjuntas dos a dos
\Function{firstInv}{$A, S$}
    \State $f \gets \Call{fact}{A}$
    \State $R \gets \ll\gg_{\langle f \rangle}$                 
    
    \If{$\Call{isEmpty}{A}$ \textbf{or} $\Call{isEmpty}{S}$}
        \State \Return $R$
    \EndIf

    \State $s\_sp \gets \mathrm{calculatePerimeter}(S)$
    \State $s\_max \gets \mathrm{maxPer}(s\_sp)$
    \State $visited \gets \{\}_{\langle f \rangle}$
    
    \ForAll{$a \in A$}
        \State $a\_sp \gets \mathrm{setPer}(a)$ 
        \State $a\_m \gets \Call{map}{a}$
        \State $m\_min \gets \mathrm{minPer}(a\_sp)$
        
        \If{$\mathrm{doInt}(a\_sp, s\_sp)$}
            \State $img \gets \Call{image}{a\_m, S}$
    
            \If{$\neg \Call{isEmpty}{img}$}
                
                
                \If{$\neg\Call{isEmpty}{visited}$}
                    \State $i\_sp \gets \mathrm{calculatePerimeter}(img)$
                    \State $v\_sp \gets \mathrm{calculatePerimeter}(visited)$
                    \If{$\mathrm{doInt}(i\_sp, v\_sp)$}
                        \State $diff\_dom \gets \Call{difference}{img, visited}$
    
                        \If{$\Call{isEmpty}{diff\_dom}$}
                            \State \textbf{continue}
                        \Else
                            \State $img \gets diff\_dom$
                        \EndIf
                    \Else
                    \EndIf
                \Else
                \EndIf

                \State $pre \gets \Call{preImage}{a\_m, img}$
                \State $exp\_val \gets \Call{exp}{a\_m}$
                \State $new\_map \gets \{pre \rightarrow exp\_val\}_{\langle f \rangle}$
                \State $inv \gets \Call{minInv}{new\_map}$
                \State $\mathrm{pushBack}(R,inv)$ 
                \State $visited \gets \Call{disjointCup}{visited, img}$
            \EndIf
            
            \State \textbf{continue} 
        \EndIf

        

        \If{$s\_max[0] < m\_min[0]$} 
            \State \textbf{break}    
        \EndIf
    \EndFor

    \State $ \mathrm{sort}(R,\mathrm{mapEntryComp})$
    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Desplazamiento de dominio - \texttt{offsetDom}}

Finalmente, se concluye con la operación \texttt{offsetDom}, la cual, como se mencionó anteriormente, dispone de un \textbf{criterio de parada} y un \textbf{criterio de solapamiento}. Al igual que en el caso anterior, se emplea un algoritmo de ordenamiento para garantizar que la salida de la operación quede correctamente ordenada.

El pseudocódigo de esta operación se presenta en la Figura~\ref{alg:ooffsetDom-ord}, donde puede observarse que:

\begin{itemize}
    \item El \textbf{criterio de parada} se aplica entre las líneas 19 y 21.
    \item El \textbf{criterio de solapamiento} aparece en la línea 10, a través de la operación auxiliar \texttt{doInt}, aplicada sobre el perímetro de $a$ y el de $O$.
\end{itemize}



\begin{algorithm}
\caption{Desplazamiento de dominio para \textit{piecewise maps} ordenados}
\label{alg:ooffsetDom-ord}
\begin{algorithmic}[1]
\Require $A$ es un \textit{piecewise map} ordenado, $O$ es un \textit{piecewise map} ordenado que actuara de offset
\Ensure Devuelve un \textit{piecewise map} ordenado cada mapa de $A$ desplazado según la imagen de $O$
\Function{offsetDom}{$A, O$}
    \State $f \gets \Call{fact}{A}$
    \State $R \gets \ll\gg_{\langle f \rangle}$
    \State $o\_sp \gets \mathrm{calculatePerimeter}(\Call{dom}{O})$
    \State $o\_dom\_max \gets \mathrm{maxPer}(o\_sp)$
    
    \ForAll{$a \in A$}
        \State $a\_m \gets\mathrm{map}(a)$
        \State $a\_sp \gets \mathrm{setPer}{a}$
        \State $m\_min \gets\mathrm{minPer}{a\_sp}$

        \If{$\mathrm{doInt}(a\_sp, o\_sp)$}
            \State $a\_m\_dom \gets \Call{dom}{a\_m}$
            \State $new\_dom \gets \Call{image}{O, a\_m\_dom}$
            \State $exp\_val \gets \Call{exp}{a\_m}$

            \If{$\neg\,\Call{isEmpty}{new\_dom}$}
                \State $new\_map \gets \{new\_dom \rightarrow exp\_val\}_f$
                \State $\mathrm{pushBack}(R,new\_map)$ 
            \EndIf
        \EndIf

        \If{$o\_dom\_max[0] < m\_min[0]$} 
            \State \textbf{break} \EndIf
    \EndFor

    \State $\mathrm{sort}(R, \mathrm{mapEntryComp})$
    \State \Return $R$
\EndFunction
\end{algorithmic}
\end{algorithm}
```
